# -*- coding: utf-8 -*-
"""hw4_group13_question_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1m0fpF2O_9jJEWhaaqpK0UTyepJ2LgkVA
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import collections
from collections import Counter as ctrs
from collections import Counter

df = {
    "Age": [24,53,23,25,32,52,22,43,52,48],
    "Salary ($)": [40000,52000,25000,77000,48000,110000,38000,44000,27000,65000],
    "College degree": ['yes','no','no','yes','yes','yes','yes','no','no','yes']
}

df = pd.DataFrame(df)

df = df.replace({'College degree': {'yes':1,'no':0}})

X = df.iloc[:,[0,1]]
y = df['College degree'].values

from sklearn import tree
clf = tree.DecisionTreeClassifier()
clf = clf.fit(X, y)

tree.plot_tree(clf)

class Node:
 
   def __init__(
       self,
       Y: list,
       X: pd.DataFrame,
       mss=None,
       mx_d=None,
       dh=None,
       n_t=None,
       rl=None
   ):
       self.Y = Y
       self.X = X
 
       self.mss = mss if mss else 20
       self.mx_d = mx_d if mx_d else 5
 
       self.dh = dh if dh else 0
 
       self.fet = list(self.X.columns)
 
       self.n_t = n_t if n_t else 'root'
 
       self.rl = rl if rl else ""
 
       self.cts = ctrs(Y)
 
       self.gi = self.g_gn()
 
       cs = list(sorted(self.cts.items(), key=lambda item: item[1]))
 
       yhat = None
       if len(cs) > 0:
           yhat = cs[-1][0]
 
       self.yhat = yhat
 
       self.n = len(Y)
 
       self.lt = None
       self.rt = None
       self.bt_fue = None
       self.bt_vl = None
 
   @staticmethod
   def ma(x: np.array, window: int) -> np.array:
       return np.convolve(x, np.ones(window), 'valid') / window
 
   def g_gn(self):
 
       yc1, yc2 = self.cts.get(0, 0), self.cts.get(1, 0)
 
       return self.gi(yc1, yc2)

   @staticmethod
   def gi(yc1: int, yc2: int) -> float:
       if yc1 is None:
           yc1 = 0
 
       if yc2 is None:
           yc2 = 0
       n1 = yc1 + yc2
       if n1 == 0:
           return 0.0
 
       p1 = yc1 / n1
       p2 = yc2 / n1
       gn = 1 - (p1 ** 2 + p2 ** 2)
       return gn
 
   def bt_split(self) -> tuple:
 
       df = self.X.copy()
       df['Y'] = self.Y
 
       GNS_base = self.g_gn()
 
       max_ga = 0
 
       bt_fue = None
       bt_vl = None
 
       for fue in self.fet:
           Xdf = df.dropna().sort_vls(fue)
 
           xmeans = self.ma(Xdf[fue].unique(), 2)
 
           for vl in xmeans:
   
               cl = ctrs(Xdf[Xdf[fue]<vl]['Y'])
               cr = ctrs(Xdf[Xdf[fue]>=vl]['Y'])
 
               y0_lt, y1_lt, y0_rt, y1_rt = cl.get(0, 0), cl.get(1, 0), cr.get(0, 0), cr.get(1, 0)
 
               gn_lt = self.gi(y0_lt, y1_lt)
               gn_rt = self.gi(y0_rt, y1_rt)
 
               n_lt = y0_lt + y1_lt
               n_rt = y0_rt + y1_rt
 
               w_lt = n_lt / (n_lt + n_rt)
               w_rt = n_rt / (n_lt + n_rt)
 
               wGNS = w_lt * gn_lt + w_rt * gn_rt
 
               GNSga = GNS_base - wGNS
 
   
               if GNSga > max_ga:
                   bt_fue = fue
                   bt_vl = vl
                   max_ga = GNSga
 
       return (bt_fue, bt_vl)
 
   def print_info(self, width=4):
       const = int(self.dh * width ** 1.5)
       spaces = "-" * const
      
       if self.n_t == 'root':
           print("Root")
       else:
           print(f"|{spaces} Split rl: {self.rl}")
       print(f"{' ' * const} impurity: {round(self.gi, 2)}")
       print(f"{' ' * const} Predicted class: {self.yhat}")  

   def gt(self):
 
       df = self.X.copy()
       df['Y'] = self.Y
 
       if (self.dh < self.mx_d) and (self.n >= self.mss):
 
           bt_fue, bt_vl = self.bt_split()
 
           if bt_fue is not None:
   
               self.bt_fue = bt_fue
               self.bt_vl = bt_vl
 
               lt_df, rt_df = df[df[bt_fue]<=bt_vl].copy(), df[df[bt_fue]>bt_vl].copy()
 
               lt = Node(
                   lt_df['Y'].vls.tolist(),
                   lt_df[self.fet],
                   dh=self.dh + 1,
                   mx_d=self.mx_d,
                   mss=self.mss,
                   n_t='lt_node',
                   rl=f"{bt_fue} <= {round(bt_vl, 3)}"
                   )
 
               self.lt = lt
               self.lt.gt()
 
               rt = Node(
                   rt_df['Y'].vls.tolist(),
                   rt_df[self.fet],
                   dh=self.dh + 1,
                   mx_d=self.mx_d,
                   mss=self.mss,
                   n_t='rt_node',
                   rl=f"{bt_fue} > {round(bt_vl, 3)}"
                   )
 
               self.rt = rt
               self.rt.gt()
 

 
   def predict(self, X:pd.DataFrame):
 
       pred = []
 
       for _, x in X.iterrows():
           vls = {}
           for fue in self.fet:
               vls.update({fue: x[fue]})
      
           pred.append(self.predict_obs(vls))
      
       return pred

   def pt_tr(self):
 
       self.print_info()
      
       if self.lt is not None:
           self.lt.pt_tr()
      
       if self.rt is not None:
           self.rt.pt_tr()
 

 
   def predict_obs(self, vls: dict) -> int:
 
       cnd = self
       while cnd.dh < cnd.mx_d:
    
           bt_fue,bt_vl = self.bt_split()
          
           if cnd.n < cnd.mss:
               break
 
           if (vls.get(bt_fue) < bt_vl):
               if self.lt is not None:
                   cnd = cnd.lt
           else:
               if self.rt is not None:
                   cnd = cnd.rt
          
       return cnd.yhat

hp = {
 'mx_d': None,
 'mss': 2
}

type(X)

root = Node(y,X,**hp)

root.pt_tr()

